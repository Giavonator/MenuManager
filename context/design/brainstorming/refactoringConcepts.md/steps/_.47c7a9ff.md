---
timestamp: 'Thu Oct 23 2025 06:10:38 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251023_061038.fe6f1147.md]]'
content_id: 47c7a9ffdb256dc528ea6ccc33b845a82a8c8514fa129906e5da0d1d15c64364
---

# MenuManager (AI Augmentation)

**concept** Menu \[User]

**purpose** creating recipes for full course meals

**principle** A friendly chef embarks on their journey of creating a delicious five course menu with amazing different recipes. They *createMenu* with the specific date of the event and starts by adding their first recipe. Creating their first recipe: *createRecipe*. As they are adding ingredients they realize that most of them haven't been used before. They then *enterItem* into the system with appropriate price and quantity information for each new ingredient, allowing them to *updateRecipeIngredient* to their recipe with the appropriate amount of the ingredient they want have for their recipe. They continue finishing up the recipe with additional *updateRecipeIngredient* when they realize they put the wrong recipe name, and change it via *updateRecipe*. Luckily a NEW LLM feature has been added that allows the chef to directly *pullRecipeFromWebsite* using website URL. The LLM is able to parse a good amount of the recipe, but the chef must *updateRecipeIngredient* and *updateRecipe* for a couple things. If the LLM is also unable to add a couple items, thats okay, the chef will simply *updateRecipeIngredient* to add new ingredients. Unfortunately for the chefs second recipe they have it on paper, but they are still able to enter it in manually. A couple days later once our chef is done adding recipes to their menu, the administrator comes in and sees they added the new pumpernickel ingredient. The administrator figures out what the cost and where to purchase the item and *updateItem* in the system. Finally, the menu is all done and confirmed!

**state**\
    a set of Menu with\
            a set of Recipe with\
                     a set of Item with\
                              an amount Int\
                     a name String\
                     an instructions String\
                     a dishPrice Float\
                     a servingQuantity Int\
                     a scalingFactor Float\
                     a dishType String\
                     an owner User\
            a name String\
            an owner User\
            a menuCost Float\
            a date String\
.\
    a set of Item with\
            a Set of String names\ // Ex. {'pepper', 'ground pepper', 'course pepper'}
            a price Float\
            a quantity Float // Ex. 3\
            a units String // Ex. "lbs"\
            a store String\
            a confirmed Bool
.\
    a set of Cart with\
            a startDate String\
            an endDate String\
            a set of Menu\
            a weeklyCost Float\\

**actions**\
    createMenu (name: String, date: String): (menu: Menu)\
            **effects** returns new empty menu that is owned by calling user, and has name/date attributes\
    updateMenu (menu: Menu, name: String)\
    updateMenu (menu: Menu, date: String)\
            **requires** menu exists, calling user owns menu\
            **effects** update the given attribute\
.\
    pullRecipeFromWebsite(menu: Menu, recipeURL: String): (recipe: Recipe)\
            **requires** menu exists, calling user owns menu, recipeURL is a valid URL\
            **effects** Using an LLM prompt to parse through the online recipeURL, creates recipe with all the ingredients it was able to parse, it will not add new ingredients that haven't been added to the system before \
    createRecipe (menu: Menu, name: String, instructions: String, servingQuantity: Int, dishType: String, scalingFactor: Float): (recipe: Recipe)\
            **requires** menu exists, calling user owns menu \
            **effects** adds recipe with no ingredients to the menu\
    updateRecipeIngredient (menu: Menu, recipe: Recipe, item: Item, amount: Int)\
            **requires** menu exists, recipe exists in menu, calling user owns menu\
            **effects** recipe updated to have appropriate scaling of item; dishPrice and menuCost reflect new change\
    updateRecipe (menu: Menu, recipe: Recipe, instructions: String)\
    updateRecipe (menu: Menu, recipe: Recipe, servingQuantity: Int)\
    updateRecipe (menu: Menu, recipe: Recipe, scalingFactor: Float)\
    updateRecipe (menu: Menu, recipe: Recipe, dishType: String)\
    updateRecipe (menu: Menu, recipe: Recipe, name: String)\
            **requires** menu exists, recipe exists in menu, calling user owns menu\
            **effects** update the given attribute\
.\
    enterItem (name: String, price: Float, quantity: Float, units: String, store: String): (item: Item)\
            **requires** no Item already exists with name\
            **effects** returns and stores new item, confirmed flag set to false\
    confirmItem (item: Item): (item: Item)\
            **requires** item exists, item hasn't been confirmed yet, called by Administrator\
            **effects** returned item is now confirmed\
    updateItem (item: Item, price: Float)\
    updateItem (item: Item, quanitity: Float)\
    updateItem (item: Item, units: String)\
    updateItem (item: Item, store: String)\
            **requires** item exists, called by Administrator\
            **effects** update the given attribute\
    addItemName (item: Item, name: String)\
            **requires** item exists, called by Administrator\
            **effects** item now has new name that it can be referenced by\
    removeItemName (item: Item, name: String)\
            **requires** item exists, item has name, called by Administrator\
            **effects** item can no longer be referenced by name\
.\
    createCart (startDate: String)\
            **requires** startDate is a Sunday, no cart already exists with startDate\
            **effects** creates empty cart with startDate and endDate that Friday\
    addMenuToCart (cart: Cart, menu: Menu)\
            **requires** cart exists, menu exists, cart doesn't already have a menu for that menus date\
            **effects** adds menu to the cart and appropriately adjusts cart price\
    adjustRecipeScale (cart: Cart, menu: Menu, recipe: recipe, scalingFactor: Int)\
            **requires** cart, menu, and recipe all exist, recipe in menu, menu in cart\
            **effects** within the cart adjusts to have the new scaling factor of specified recipe in menu, adjust cart price appropriately \
    adjustItemQuantity (cart: Cart, menu: Menu, item: Item, quantity: Int)\
            **requires** cart, menu, and item all exist, item in some recipe in menu, menu in cart\
            **effects** within the cart adjusts number of item purchased to quantity, adjust cart price appropriately \\

**queries**\
    \_getMenusInCart (cart: Cart): (menus: Set of Menu)\
            **requires** cart exists\
            **effects** returns the set of all Menu entities associated with the given cart.

    \_getRecipesInMenu (menu: Menu): (recipes: Set of Recipe)\
            **requires** menu exists\
            **effects** returns the set of all Recipe entities associated with the given menu.

    \_getIngredientsInRecipe (recipe: Recipe): (ingredients: Map of Item to Float)\
            **requires** recipe exists\
            **effects** returns a map where each key is an Item and the value is the total scaled quantity (Float) of that item needed for the given recipe, calculated as `item.amount * recipe.scalingFactor`. The `Item`'s `units` property indicates the unit of the quantity.

    \_getIngredientsInMenu (menu: Menu): (ingredients: Map of Item to Float)\
            **requires** menu exists\
            **effects** returns a map where each key is an Item and the value is the total aggregated quantity (Float) of that item needed across all recipes within the given menu, considering each recipe's `scalingFactor`. The `Item`'s `units` property indicates the unit of the quantity.

    \_getListOfItems (): (items: Set of Item)\
            **requires** nothing\
            **effects** returns a set of all items stored within the application.

    \_getIngredientsPerStore (menus: Set of Menu): (storeShoppingList: Map of String to (Map of Item to Float))\
            **requires** all menus in the input set exist\
            **effects** returns a map where each key is a `store` name (String) and the value is another map. This inner map has `Item` keys and their total aggregated quantity (Float) values, representing the total amount of each item needed from that store across all specified menus, considering recipe scaling factors. The `Item`'s `units` property indicates the unit of the quantity.

    \_getMenuByDate (date: String): (menu: Menu)\
            **requires** menu exists for date\
            **effects** returns the menu associated with that date.

    \_getMenusOwnedByUser (user: User): (menus: Set of Menu)\
            **requires** user exists\
            **effects** returns the set of all Menu entities where the `owner` attribute matches the given user.

I've realized that having one very large concept does not work, and is a pain to implement and test. We would like to refactor the MenuManager concept into five seperate concepts: StoreCatalog, CookBook, FrenchMeal, ShoppingCart, PurchaseSystem. Instead of having one big concept, instead these basic concepts will be synchronized together to perform what the previous MenuManger was doing. Your goal is to use the old MenuManager along with the additional notes below, and write a concept file for each of the new concepts.

StoreCatalog: Should be the set of Item from MenuManager. Changes to be made:

1. Each Item should have a set of PurchaseAmount, where each PurchaseAmount has a quantity (Ex. 3) and a units ("lbs"). That way we can store different sizes of things that we would be able to purchase.

FrenchMeal: Should contain the set of Recipe, but don't include cost for the recipe. Instead for each recipe have an associated 'Order' that will be defined in PurchaseSystem. Whenever a change happens to the recipe, it will be synchronously mapped to that recipes order. Changes to be made to the recipes:

1. Recipe should no longer be tied to a Menu within its scope. Remove menu from all updateRecipe and createRecipe.
2. Creating a recipe should now only require a recipe name. The rest should be updated using updateRecipe.
3. Create an designateOwner action that asignes a User as the owner to a recipe. It must require that the recipe doesn't already have an owner.
4. Create duplicateRecipe that takes in a recipe ID and a user ID, which will duplicate the recipe and have the new user own that duplicated recipe.
5. Modify pullRecipeFromWebsite to addCopiedIngredients that should instead take in a String that would be the copy and pasting of all the ingredients from the user. This way the LLM can parse through directly the ingredients (which is most of the work), and then add them to the Recipe. This should also return the set of ingredients that were not added to the recipe. That way we are able to inform the user of ones that were forgotten.

FrenchMeal: This should be the set of Menu that have a set of Recipe, but only Recipe ID. As this is its own concept now the Menu cannot see everything that is within the Recipe, but rather is more just like a list of Recipe. The Menu should no longer have a cost, but instead an associated 'Order' that will be defined in PurchaseSystem. Changes to he made to menus:

1. Create an addRecipe action that associated a recipe ID with the Menu. The menu owner does not need to own the recipe. This addRecipe should only take the Recipe ID and a scaling for that Recipe.
2. Create changeRecipeScaling action that can change the scaling of a Recipe within the Menu.
3. Each Menu should have stored the ID of its respective Order.

ShoppingCart: This should be the set of Cart that contain the set of Menu for a specific week. It should have the startDate, endDate, set of Menu, and the ID for its respective Order.

1. List of actions should be createCart, addMenuToCart, removeMenuFromCart.

PurchaseSystem: Really the only new concept, and is replacing the set of Cart. Instead we should now have a set of Order that contain: a set of SubOrder, a set of ParentOrder, a cost Float, a purchased Flag. The actions for this concept should be: createOrder, addSubOrder, addParentOrder, removeSubOrder, removeParentOrder, marOrderAsPurchased.

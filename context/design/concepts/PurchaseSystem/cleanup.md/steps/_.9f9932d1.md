---
timestamp: 'Mon Oct 27 2025 22:28:30 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251027_222830.cc94d01a.md]]'
content_id: 9f9932d1400924cd924d93b2702f6e22398c7df4abe33862e27ebb36759decb3
---

# PurchaseSystem

**concept** PurchaseSystem \[ID]

**purpose** Manage and aggregate costs and required item quantities for various entities (recipes, menus, carts), tracking their purchase status and optimizing selections from available purchasing options.

**principle** An online optimizing purchasing system is established by first creating `AtomicOrder`s, which represent individual purchasable items or variants with specific quantities and prices. Then, `SelectOrder`s are created, representing a desired quantity of an item that *can be fulfilled by selecting from a set of available AtomicOrders*. This allows for flexibility and optimization. A `SelectOrder` will internally track which `AtomicOrder` has been optimally chosen to meet its desired quantity. These `SelectOrder`s (or other `CompositeOrder`s) can then be aggregated into `CompositeOrder`s, which allow for scaling and hierarchical structuring of purchases. At any point for a `CompositeOrder`, a `calculateOptimalPurchase` action will compute the lowest total cost by recursively determining the best `AtomicOrder` for each `SelectOrder` in its subtree. Finally, a `purchaseOrder` can be placed on any top-level `CompositeOrder`, marking all included `SelectOrder`s and `CompositeOrder`s as purchased.

**state**\
  a set of AtomicOrder with\
    an associateID ID // Associate Order to external object using a universal ID\
    a quantity Float // Ex. 3.0\
    a units String // Ex. "lbs", "oz", "count"\
    a price Float // Ex. 5.99 (cost for this specific quantity)\
    **a parentSelectOrders Set of SelectOrder** // A set of SelectOrders that offer this AtomicOrder as an option

  a set of SelectOrder with\
    an associateID ID // Associate Order to external object using a universal ID\
    a desiredQuantity Float // Ex. 5.0\
    a desiredUnits String // Ex. "lbs"\
    a childAtomicOrders Set of AtomicOrder // The set of AtomicOrders that are options for this SelectOrder\
    **an optimalAtomicOrder AtomicOrder | null** // The AtomicOrder currently selected to fulfill the desired quantity\
    a parentCompositeOrders Set of CompositeOrder\
    a purchased Bool

  a set of CompositeOrder with\
    an associateID ID // Associate Order to external object using a universal ID\
    a childOrders Map of (SelectOrder | CompositeOrder) to Float // Map from Order ID to its scale factor\
    a parentCompositeOrders Set of CompositeOrder\
    a totalCost Float // Optimally calculated\
    a purchased Bool\\

**actions**\
  createAtomicOrder (associateID: ID, quantity: Float, units: String, price: Float): (atomicOrder: AtomicOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept.\
    **effects** Creates a new `AtomicOrder` with the given parameters. Its `parentSelectOrders` is initially an empty set. Returns the new `AtomicOrder` ID.

  createSelectOrder (associateID: ID, desiredQuantity: Float, desiredUnits: String): (selectOrder: SelectOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept. `desiredQuantity` > 0.\
    **effects** Creates a new `SelectOrder` with `associateID`, `desiredQuantity`, `desiredUnits`. Initializes `childAtomicOrders` to empty, `optimalAtomicOrder` to null, and `purchased` to `false`. Returns the new `SelectOrder` ID.

  createCompositeOrder (associateID: ID): (compositeOrder: CompositeOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept.\
    **effects** Creates a new `CompositeOrder` with `associateID`. Initializes `childOrders` to empty, `totalCost` to 0.0, and `purchased` to `false`. Returns the new `CompositeOrder` ID.

  addSelectSubOrder (selectOrder: SelectOrder, atomicOrder: AtomicOrder)\
    **requires** `selectOrder` exists. `atomicOrder` exists. `atomicOrder` is not already in `selectOrder.childAtomicOrders`.\
    **effects** Adds `atomicOrder` to `selectOrder.childAtomicOrders`. Adds `selectOrder` to `atomicOrder.parentSelectOrders`. Triggers `calculateOptimalPurchase` for all `parentCompositeOrders` of `selectOrder` if `selectOrder` has a parent.

  removeSelectSubOrder (selectOrder: SelectOrder, atomicOrder: AtomicOrder)\
    **requires** `selectOrder` exists. `atomicOrder` exists and is in `selectOrder.childAtomicOrders`.\
    **effects** Removes `atomicOrder` from `selectOrder.childAtomicOrders`. Removes `selectOrder` from `atomicOrder.parentSelectOrders`. If `selectOrder.optimalAtomicOrder` was `atomicOrder`, sets `selectOrder.optimalAtomicOrder` to null. Triggers `calculateOptimalPurchase` for all `parentCompositeOrders` of `selectOrder` if `selectOrder` has a parent.

  addCompositeSubOrder (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder), scaleFactor: Float)\
    **requires** `parentCompositeOrder` exists. `childOrder` exists. `scaleFactor` > 0. `childOrder` is not already a child order of `parentCompositeOrder`.\
    **effects** Adds `childOrder` to `parentCompositeOrder.childOrders` with the given `scaleFactor`. Adds `parentCompositeOrder` to `childOrder.parentCompositeOrders`. Triggers `calculateOptimalPurchase` for `parentCompositeOrder` and its ancestors.

  removeCompositeSubOrder (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder))\
    **requires** `parentCompositeOrder` exists. `childOrder` exists and is a child order of `parentCompositeOrder`.\
    **effects** Removes `childOrder` from `parentCompositeOrder.childOrders`. Removes `parentCompositeOrder` from `childOrder.parentCompositeOrders`. Triggers `calculateOptimalPurchase` for `parentCompositeOrder` and its ancestors.

  updateSubOrderScaleFactor (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder), newScaleFactor: Float)\
    **requires** `parentCompositeOrder` exists. `childOrder` exists and is a child order of `parentCompositeOrder`. `newScaleFactor` > 0.\
    **effects** Updates the `scaleFactor` for `childOrder` in `parentCompositeOrder.childOrders`. Triggers `calculateOptimalPurchase` for `parentCompositeOrder` and its ancestors.

  calculateOptimalPurchase (compositeOrder: CompositeOrder)\
    **requires** `compositeOrder` exists. All `SelectOrder`s in its subtree have `childAtomicOrders` populated.\
    **effects** Recursively determines the optimal `AtomicOrder` for each `SelectOrder` in the `compositeOrder`'s subtree from its `childAtomicOrders`, considering their `quantity`, `units`, and `price` relative to the `SelectOrder`'s `desiredQuantity` and `desiredUnits`. Updates `selectOrder.optimalAtomicOrder` for each `SelectOrder` to reflect this choice (or null if no suitable `AtomicOrder` can be found). Updates `compositeOrder.totalCost` and the `totalCost` of all its ancestor `CompositeOrder`s based on these optimal selections and scale factors. Sets `purchased` to `false` for `compositeOrder` and all parent `CompositeOrder`s if any optimal selection changes or if a `SelectOrder` no longer has an `optimalAtomicOrder`.

  purchaseOrder (compositeOrder: CompositeOrder)\
    **requires** `compositeOrder` exists and has an empty `parentCompositeOrders` set (it is a head node). All `SelectOrder`s nested under `compositeOrder` have an `optimalAtomicOrder` selected (implicitly, through calculation).\
    **effects** Recursively sets `purchased` to `true` for `compositeOrder` and all `SelectOrder`s and `CompositeOrder`s in its subtree.

  deleteOrder (order: (AtomicOrder | SelectOrder | CompositeOrder))\
    **requires** `order` exists.\
    **effects** Deletes the specified `order` and updates affected relationships and calculations.\
    - If `order` is an `AtomicOrder`:\
        - For each `s` in `order.parentSelectOrders`: removes `order` from `s.childAtomicOrders`. If `s.optimalAtomicOrder` was `order`, sets `s.optimalAtomicOrder` to null. Triggers `calculateOptimalPurchase` for all `parentCompositeOrders` of `s`.\
        - Deletes `order` itself.
    - If `order` is a `SelectOrder`:\
        - For each `ao` in `order.childAtomicOrders`: removes `order` from `ao.parentSelectOrders`.\
        - For each `pco` in `order.parentCompositeOrders`: removes `order` from `pco.childOrders`. Triggers `calculateOptimalPurchase` for `pco` and its ancestors.\
        - Deletes `order` itself.
    - If `order` is a `CompositeOrder`:\
        - For each `pco` in `order.parentCompositeOrders`: removes `order` from `pco.childOrders`. Triggers `calculateOptimalPurchase` for `pco` and its ancestors.\
        - For each `child` in `order.childOrders` (SelectOrder or CompositeOrder): removes `order` from `child.parentCompositeOrders`.\
        - Deletes `order` itself.

**queries**\
  \_getAtomicOrderDetails (atomicOrder: AtomicOrder): (associateID: ID, quantity: Float, units: String, price: Float, parentSelectOrders: Set of SelectOrder)\
    **requires** `atomicOrder` exists.\
    **effects** Returns the `associateID`, `quantity`, `units`, `price`, and `parentSelectOrders` of the `atomicOrder`.

  \_getSelectOrderDetails (selectOrder: SelectOrder): (associateID: ID, desiredQuantity: Float, desiredUnits: String, childAtomicOrders: Set of AtomicOrder, optimalAtomicOrder: AtomicOrder | null, purchased: Bool, parentCompositeOrders: Set of CompositeOrder)\
    **requires** `selectOrder` exists.\
    **effects** Returns the `associateID`, `desiredQuantity`, `desiredUnits`, `childAtomicOrders`, `optimalAtomicOrder`, `purchased`, and `parentCompositeOrders` of the `selectOrder`.

  \_getCompositeOrderDetails (compositeOrder: CompositeOrder): (associateID: ID, childOrders: Map of (SelectOrder | CompositeOrder) to Float, totalCost: Float, purchased: Bool, parentCompositeOrders: Set of CompositeOrder)\
    **requires** `compositeOrder` exists.\
    **effects** Returns the `associateID`, `childOrders`, `totalCost`, `purchased`, and `parentCompositeOrders` of the `compositeOrder`.

  \_getOrderByAssociateID (associateID: ID): (order: (AtomicOrder | SelectOrder | CompositeOrder))\
    **requires** Order exists with `associateID`.\
    **effects** Returns the `order` associated with that ID.

  \_getOptimalPurchase (compositeOrder: CompositeOrder): (optimalCost: Float, selectedAtomicOrders: Map of SelectOrder to AtomicOrder)\
    **requires** `compositeOrder` exists. `calculateOptimalPurchase` has been run for this `compositeOrder` and its sub-tree.\
    **effects** Returns the calculated `compositeOrder.totalCost` and a map of each `SelectOrder` in its subtree to the `AtomicOrder` that was optimally selected for it during the last `calculateOptimalPurchase` operation.

  \_getOrderCost (compositeOrder: CompositeOrder): (totalCost: Float)\
    **requires** `compositeOrder` exists.\
    **effects** Returns the `totalCost` of the `compositeOrder`.

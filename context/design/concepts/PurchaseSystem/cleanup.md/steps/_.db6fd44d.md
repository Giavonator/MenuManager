---
timestamp: 'Tue Oct 28 2025 10:28:46 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251028_102846.daf840aa.md]]'
content_id: db6fd44d82c34ebe18c3f71d7dd48c7038c4cbf932368c6313012be97e93552d
---

# PurchaseSystem

**concept** PurchaseSystem \[ID]

**purpose** Manage and aggregate costs and required item quantities for various entities (recipes, menus, carts), tracking their purchase status and optimizing selections from available purchasing options.

**principle** An online optimizing purchasing system first allows the `createAtomicOrder` action to register specific purchasable items with their quantities, units, and prices. These `AtomicOrder`s can then be associated as options with one or more `SelectOrder`s. Before that a `CompositeOrder` is created using `createCompositeOrder` and a globally unique ID that maps to what the order is for. To this CompositeOrder we can `addCompositeSubOrder` which will add a scaling to either a different CompositeOrder or a SelectOrder (note, SelectOrder/CompositeOrder must only have one parent order). At any point for a CompositeOrder a `calculateOptimalPurchase` will find the root CompositeOrder of that tree, and calculate the optimal costs for everything in its subtree. Finally, a `purchaseOrder` can be placed on any head CompositeOrder (has no parents) and it will mark every SelectOrder and CompositeOrder in its subtree as purchased.

A `createSelectOrder` action defines a desired item and its quantity, which can then use `addAtomicOptionToSelectOrder` to add possible `AtomicOrder` to select from.

**state**\
  a set of AtomicOrder with\
    an associateID ID // Associate Order to external globally unique ID\
    a quantity Float // Ex. 3.0\
    a units String // Ex. "lbs", "oz", "count"\
    a price Float // Ex. 5.99 (cost for this specific quantity)\
    a parentSelectOrders Set of SelectOrder

  a set of SelectOrder with\
    an associateID ID // Associate Order to external globally unique ID\
    a desiredQuantity Float // Ex. 5.0\
    a desiredUnits String // Ex. "lbs", internal unit conversion table if AtomicOrder has different units\
    a childAtomicOrders Set of AtomicOrder // AtomicOrder options available for *this* SelectOrder.\
    a parentOrder CompositeOrder // *Updated: Singular parent* \
    a purchased Bool

  a set of CompositeOrder with\
    an associateID ID // Associate Order to external globally unique ID\
    a childOrders Map of (SelectOrder | CompositeOrder) to Float // Scale factor that is used during optimalPurchaseCalculation to muyltiply subOrder scaleFactors/desiredQuantities\
    an optimalPurchase Map of AtomicOrder to Int // Calculated during calculateOptimalPurchase, must purchase whole AtomicOrders\
    a totalCost Float // Optimally calculated\
    a parentOrder CompositeOrder // *Updated: Singular parent* \
    a purchased Bool

**actions**\
  createAtomicOrder (associateID: ID, quantity: Float, units: String, price: Float): (atomicOrder: AtomicOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept.\
    **effects** Creates a new `AtomicOrder` with the given parameters. Its `parentSelectOrders` set is initially empty. Returns the new `AtomicOrder` ID.

  createSelectOrder (associateID: ID, parentOrder: CompositeOrder, desiredQuantity: Float, desiredUnits: String): (selectOrder: SelectOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept. `desiredQuantity` > 0.\
    **effects** Creates a new `SelectOrder` with `associateID`, `desiredQuantity`, `desiredUnits`. Its `parentOrder` is set to `parentOrder`. Initializes `childAtomicOrders` to empty and `purchased` to `false`. Returns the new `SelectOrder` ID.

  createCompositeOrder (associateID: ID): (compositeOrder: CompositeOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept.\
    **effects** Creates a new `CompositeOrder` with `associateID`. Initializes `childOrders` to empty, `totalCost` to 0.0, `purchased` to `false`, and `parentOrder` to `null`. Returns the new `CompositeOrder` ID.

  addAtomicOptionToSelectOrder (selectOrder: SelectOrder, atomicOrder: AtomicOrder)\
    **requires** `selectOrder` exists. `atomicOrder` exists. `atomicOrder` is not already in `selectOrder.childAtomicOrders`.\
    **effects** Adds `atomicOrder` to `selectOrder.childAtomicOrders`. Adds `selectOrder` to `atomicOrder.parentSelectOrders`. Calls `calculateOptimalPurchase` for the root `CompositeOrder` of `selectOrder`'s parent chain.

  removeAtomicOptionToSelectOrder (selectOrder: SelectOrder, atomicOrder: AtomicOrder)\
    **requires** `selectOrder` exists. `atomicOrder` exists and is in `selectOrder.childAtomicOrders`.\
    **effects** Removes `atomicOrder` from `selectOrder.childAtomicOrders`. Removes `selectOrder` from `atomicOrder.parentSelectOrders`. Calls `calculateOptimalPurchase` for the root `CompositeOrder` of `selectOrder`'s parent chain.

  addCompositeSubOrder (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder), scaleFactor: Float)\
    **requires** `parentCompositeOrder` exists. `childOrder` exists. `scaleFactor` > 0. `childOrder` is not already a child order of `parentCompositeOrder`. **`childOrder.parentOrder` is `null`.**\
    **effects** Adds `childOrder` to `parentCompositeOrder.childOrders` with the given `scaleFactor`. Sets `childOrder.parentOrder := parentCompositeOrder`. Calls `calculateOptimalPurchase` for the root `CompositeOrder` of `parentCompositeOrder`'s parent chain.

  removeCompositeSubOrder (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder))\
    **requires** `parentCompositeOrder` exists. `childOrder` exists and is a child order of `parentCompositeOrder`.\
    **effects** Removes `childOrder` from `parentCompositeOrder.childOrders`. Sets `childOrder.parentOrder := null`. Calls `calculateOptimalPurchase` for the root `CompositeOrder` of `parentCompositeOrder`'s parent chain.

  updateSubOrderScaleFactor (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder), newScaleFactor: Float)\
    **requires** `parentCompositeOrder` exists. `childOrder` exists and is a child order of `parentCompositeOrder`. `newScaleFactor` > 0.\
    **effects** Updates the `scaleFactor` for `childOrder` in `parentCompositeOrder.childOrders`. Calls `calculateOptimalPurchase` for the root `CompositeOrder` of `parentCompositeOrder`'s parent chain.

  calculateOptimalPurchase (compositeOrder: CompositeOrder)\
    **requires** `compositeOrder` exists. `compositeOrder` has not been purchased. All `SelectOrder`s in its subtree have at least one `AtomicOrder` within their `childAtomicOrders`.\
    **effects** If `compositeOrder.parentOrder` is not `null`, recursively calls `calculateOptimalPurchase` on `compositeOrder.parentOrder`, as optimal calculations must be done at the root order of the tree. From the head `compositeOrder` (the root of the tree), determines the optimal `compositeOrder.totalCost` and `compositeOrder.optimalPurchase`. This is done by aggregating all `AtomicOrder` leaf orders (with their scalings propagated from down the tree), and optimally choosing the set of `AtomicOrders` that satisfy all `SelectOrder` in the tree for the least amount of cost. These selections are then propagated up through the tree so the `totalCost` and `optimalPurchase` are all set for every `CompositeOrder` within the tree up until the root order.

  purchaseOrder (compositeOrder: CompositeOrder)\
    **requires** `compositeOrder` exists and `compositeOrder.parentOrder` is `null` (it is a head node). All `SelectOrder`s and `CompositeOrder`s within tree rooted at `compositeOrder` are not purchased.\
    **effects** Recursively sets `purchased` to `true` for `compositeOrder` and all `SelectOrder`s and `CompositeOrder`s in its subtree.

  deleteOrder (order: (AtomicOrder | SelectOrder | CompositeOrder))\
    **requires** `order` exists.\
    **effects** Deletes the specified `order`. If the deleted `order` had a parent, calls `calculateOptimalPurchase` for the root `CompositeOrder` of that parent's chain afterwards.\
    - If `order` is an `AtomicOrder`:\
        - For each `pso` in `order.parentSelectOrders`: removes `order` from `pso.childAtomicOrders`.\
    - If `order` is a `SelectOrder`:\
        - If `order.parentOrder` exists: removes `order` from `order.parentOrder.childOrders`.\
        - For each `ao` in `order.childAtomicOrders`: removes `order` from `ao.parentSelectOrders`.\
    - If `order` is a `CompositeOrder`:\
        - If `order.parentOrder` exists: removes `order` from `order.parentOrder.childOrders`.\
        - For each `childOrder` in `order.childOrders`'s keys: sets `childOrder.parentOrder := null` (orphaning its direct children).\\

**queries**\
  \_getAtomicOrderDetails (atomicOrder: AtomicOrder): (associateID: ID, quantity: Float, units: String, price: Float, parentSelectOrders: Set of SelectOrder)\
    **requires** `atomicOrder` exists.\
    **effects** Returns the `associateID`, `quantity`, `units`, `price`, and `parentSelectOrders` of the `atomicOrder`.

  \_getSelectOrderDetails (selectOrder: SelectOrder): (associateID: ID, desiredQuantity: Float, desiredUnits: String, childAtomicOrders: Set of AtomicOrder, purchased: Bool, parentCompositeOrder: CompositeOrder)\
    **requires** `selectOrder` exists.\
    **effects** Returns the `associateID`, `desiredQuantity`, `desiredUnits`, `childAtomicOrders`, `purchased`, and `parentOrder` of the `selectOrder`.

  \_getCompositeOrderDetails (compositeOrder: CompositeOrder): (associateID: ID, childOrders: Map of (SelectOrder | CompositeOrder) to Float, totalCost: Float, purchased: Bool, parentCompositeOrder: CompositeOrder)\
    **requires** `compositeOrder` exists.\
    **effects** Returns the `associateID`, `childOrders`, `totalCost`, `purchased`, and `parentOrder` of the `compositeOrder`.

  \_getOrderByAssociateID (associateID: ID): (order: (AtomicOrder | SelectOrder | CompositeOrder))\
    **requires** Order exists with `associateID`.\
    **effects** Returns the `order` associated with that ID.

  \_getOptimalPurchase (compositeOrder: CompositeOrder): (optimalCost: Float, selectedAtomicOrders: Map of SelectOrder to AtomicOrder)\
    **requires** `compositeOrder` exists. `calculateOptimalPurchase` has been run for this `compositeOrder` and its sub-tree.\
    **effects** Returns the calculated `compositeOrder.totalCost` and a map of each `SelectOrder` in its subtree to the `AtomicOrder` that was optimally selected for it during the last `calculateOptimalPurchase` operation.

  \_getOrderCost (compositeOrder: CompositeOrder): (totalCost: Float)\
    **requires** `compositeOrder` exists.\
    **effects** Returns the `totalCost` of the `compositeOrder`.

---
timestamp: 'Mon Oct 27 2025 22:31:20 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251027_223120.38e5a10d.md]]'
content_id: be8f89a3d671b75789022f7c55fbf98fd9ed57e0379ee3d4ed77c0d3f5066db0
---

# PurchaseSystem

**concept** PurchaseSystem \[ID]

**purpose** Manage and aggregate costs and required item quantities for various entities (recipes, menus, carts), tracking their purchase status and optimizing selections from available purchasing options.

**principle** An online optimizing purchasing system that first `createAtomicOrder` the different variants of something to purchase. These `AtomicOrder`s serve as options. A `createSelectOrder` is then used to define a desired item, and can incorporate multiple `AtomicOrder`s as its purchasing options. When `calculateOptimalPurchase` is run, a `SelectOrder` will choose its best available `AtomicOrder` option to meet its desired quantity, storing this selection. A set of items are then composed into a `createCompositeOrder`, which starts from a base `SelectOrder` and its scaling. To this `CompositeOrder` we can `addSubOrder` which will add a scaling to either a different `CompositeOrder` or a `SelectOrder`. At any point for a `CompositeOrder` a `calculateOptimalPurchase` will calculate and update the cost for that `CompositeOrder` and its sub-orders, reflecting the optimal selections made by `SelectOrder`s. Finally, a `purchaseOrder` can be placed on any head `CompositeOrder` (has no parents) and it will mark every `SelectOrder` and `CompositeOrder` in its subtree as purchased. If an `AtomicOrder`'s properties (like price) change, `calculateOptimalPurchase` can be re-run to find a new optimal selection and cost.

**state**\
  a set of AtomicOrder with\
    an associateID ID // Associate Order to external object using a universal ID\
    a quantity Float // Ex. 3.0\
    a units String // Ex. "lbs", "oz", "count"\
    a price Float // Ex. 5.99 (cost for this specific quantity)\
    a parentSelectOrders Set of SelectOrder // **CHANGED: AtomicOrder can be an option for multiple SelectOrders**

  a set of SelectOrder with\
    an associateID ID // Associate Order to external object using a universal ID\
    a desiredQuantity Float // Ex. 5.0\
    a desiredUnits String // Ex. "lbs"\
    a childAtomicOrders Set of AtomicOrder // These are the options from which one will be selected\
    an optimalAtomicOrder AtomicOrder? // **ADDED: The AtomicOrder currently selected as optimal**\
    a parentCompositeOrders Set of CompositeOrder\
    a purchased Bool

  a set of CompositeOrder with\
    an associateID ID // Associate Order to external object using a universal ID\
    a childOrders Map of (SelectOrder | CompositeOrder) to Float // Map from Order ID to its scale factor\
    a parentCompositeOrders Set of CompositeOrder\
    a totalCost Float // Optimally calculated\
    a purchased Bool\\

**actions**\
  createAtomicOrder (associateID: ID, quantity: Float, units: String, price: Float): (atomicOrder: AtomicOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept.\
    **effects** Creates a new `AtomicOrder` with the given parameters. Its `parentSelectOrders` is initially an empty set. Returns the new `AtomicOrder` ID.

  createSelectOrder (associateID: ID, desiredQuantity: Float, desiredUnits: String): (selectOrder: SelectOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept. `desiredQuantity` > 0.\
    **effects** Creates a new `SelectOrder` with `associateID`, `desiredQuantity`, `desiredUnits`. Initializes `purchased` to `false`, `childAtomicOrders` to empty, and `optimalAtomicOrder` to `null`. Returns the new `SelectOrder` ID.

  createCompositeOrder (associateID: ID): (compositeOrder: CompositeOrder)\
    **requires** No order already exists for `associateID` within this `PurchaseSystem` concept.\
    **effects** Creates a new `CompositeOrder` with `associateID`. Initializes `childOrders` to empty, `totalCost` to 0.0, and `purchased` to `false`. Returns the new `CompositeOrder` ID.

  addSelectSubOrder (selectOrder: SelectOrder, atomicOrder: AtomicOrder)\
    **requires** `selectOrder` exists. `atomicOrder` exists. `atomicOrder` is not already in `selectOrder.childAtomicOrders` (and `selectOrder` is not already in `atomicOrder.parentSelectOrders`).\
    **effects** Adds `atomicOrder` to `selectOrder.childAtomicOrders`. Adds `selectOrder` to `atomicOrder.parentSelectOrders`. Triggers `calculateOptimalPurchase` for all `parentCompositeOrders` of `selectOrder`.

  removeSelectSubOrder (selectOrder: SelectOrder, atomicOrder: AtomicOrder)\
    **requires** `selectOrder` exists. `atomicOrder` exists and is in `selectOrder.childAtomicOrders`.\
    **effects** Removes `atomicOrder` from `selectOrder.childAtomicOrders`. Removes `selectOrder` from `atomicOrder.parentSelectOrders`. If `selectOrder.optimalAtomicOrder` was `atomicOrder`, sets `selectOrder.optimalAtomicOrder` to `null`. Triggers `calculateOptimalPurchase` for all `parentCompositeOrders` of `selectOrder`.

  addCompositeSubOrder (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder), scaleFactor: Float)\
    **requires** `parentCompositeOrder` exists. `childOrder` exists. `scaleFactor` > 0. `childOrder` is not already a child order of `parentCompositeOrder`.\
    **effects** Adds `childOrder` to `parentCompositeOrder.childOrders` with the given `scaleFactor`. Adds `parentCompositeOrder` to `childOrder.parentCompositeOrders`. Triggers `calculateOptimalPurchase` for `parentCompositeOrder` and its ancestors.

  removeCompositeSubOrder (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder))\
    **requires** `parentCompositeOrder` exists. `childOrder` exists and is a child order of `parentCompositeOrder`.\
    **effects** Removes `childOrder` from `parentCompositeOrder.childOrders`. Removes `parentCompositeOrder` from `childOrder.parentCompositeOrders`. Triggers `calculateOptimalPurchase` for `parentCompositeOrder` and its ancestors.

  updateSubOrderScaleFactor (parentCompositeOrder: CompositeOrder, childOrder: (SelectOrder | CompositeOrder), newScaleFactor: Float)\
    **requires** `parentCompositeOrder` exists. `childOrder` exists and is a child order of `parentCompositeOrder`. `newScaleFactor` > 0.\
    **effects** Updates the `scaleFactor` for `childOrder` in `parentCompositeOrder.childOrders`. Triggers `calculateOptimalPurchase` for `parentCompositeOrder` and its ancestors.

  calculateOptimalPurchase (compositeOrder: CompositeOrder)\
    **requires** `compositeOrder` exists. All `SelectOrder`s in its subtree have `childAtomicOrders` populated.\
    **effects** Recursively determines the optimal `AtomicOrder` for each `SelectOrder` in the `compositeOrder`'s subtree and updates `selectOrder.optimalAtomicOrder` for each `SelectOrder`. Updates `compositeOrder.totalCost` and the `totalCost` of all its ancestor `CompositeOrder`s based on these optimal selections and scale factors. Sets `purchased` to `false` for `compositeOrder` and all parent `CompositeOrder`s if any `optimalAtomicOrder` selection changes for any `SelectOrder` in the subtree, or if the `totalCost` changes.

  purchaseOrder (compositeOrder: CompositeOrder)\
    **requires** `compositeOrder` exists and has an empty `parentCompositeOrders` set (it is a head node). All `SelectOrder`s nested under `compositeOrder` have an `optimalAtomicOrder` selected (explicitly via the `optimalAtomicOrder` field).\
    **effects** Recursively sets `purchased` to `true` for `compositeOrder` and all `SelectOrder`s and `CompositeOrder`s in its subtree.

  deleteOrder (order: (AtomicOrder | SelectOrder | CompositeOrder))\
    **requires** `order` exists.\
    **effects** Deletes the specified `order`.\
    - If `order` is an `AtomicOrder`:\
        - For each `pso` in `order.parentSelectOrders`: removes `order` from `pso.childAtomicOrders`. If `pso.optimalAtomicOrder` was `order`, sets `pso.optimalAtomicOrder` to `null`. Triggers `calculateOptimalPurchase` for all `parentCompositeOrders` of `pso`.\
        - Deletes the `AtomicOrder` instance itself.\
    - If `order` is a `SelectOrder`:\
        - For each `pco` in `order.parentCompositeOrders`: removes `order` from `pco.childOrders`. Triggers `calculateOptimalPurchase` for `pco` and its ancestors.\
        - For each `ao` in `order.childAtomicOrders`: removes `order` from `ao.parentSelectOrders`.\
        - Deletes the `SelectOrder` instance itself.\
    - If `order` is a `CompositeOrder`:\
        - For each `pco` in `order.parentCompositeOrders`: removes `order` from `pco.childOrders`. Triggers `calculateOptimalPurchase` for `pco` and its ancestors.\
        - Removes references to its own `childOrders`. Deletes the `CompositeOrder` instance itself.

**queries**\
  \_getAtomicOrderDetails (atomicOrder: AtomicOrder): (associateID: ID, quantity: Float, units: String, price: Float, parentSelectOrders: Set of SelectOrder)\
    **requires** `atomicOrder` exists.\
    **effects** Returns the `associateID`, `quantity`, `units`, `price`, and `parentSelectOrders` of the `atomicOrder`.

  \_getSelectOrderDetails (selectOrder: SelectOrder): (associateID: ID, desiredQuantity: Float, desiredUnits: String, childAtomicOrders: Set of AtomicOrder, optimalAtomicOrder: AtomicOrder?, purchased: Bool, parentCompositeOrders: Set of CompositeOrder)\
    **requires** `selectOrder` exists.\
    **effects** Returns the `associateID`, `desiredQuantity`, `desiredUnits`, `childAtomicOrders`, `optimalAtomicOrder`, `purchased`, and `parentCompositeOrders` of the `selectOrder`.

  \_getCompositeOrderDetails (compositeOrder: CompositeOrder): (associateID: ID, childOrders: Map of (SelectOrder | CompositeOrder) to Float, totalCost: Float, purchased: Bool, parentCompositeOrders: Set of CompositeOrder)\
    **requires** `compositeOrder` exists.\
    **effects** Returns the `associateID`, `childOrders`, `totalCost`, `purchased`, and `parentCompositeOrders` of the `compositeOrder`.

  \_getOrderByAssociateID (associateID: ID): (order: (AtomicOrder | SelectOrder | CompositeOrder))\
    **requires** Order exists with `associateID`.\
    **effects** Returns the `order` associated with that ID.

  \_getOptimalPurchase (compositeOrder: CompositeOrder): (optimalCost: Float, selectedAtomicOrders: Map of SelectOrder to AtomicOrder)\
    **requires** `compositeOrder` exists. `calculateOptimalPurchase` has been run for this `compositeOrder` and its sub-tree.\
    **effects** Returns the calculated `compositeOrder.totalCost` and a map of each `SelectOrder` in its subtree to the `AtomicOrder` that was optimally selected for it during the last `calculateOptimalPurchase` operation (as stored in `SelectOrder.optimalAtomicOrder`).

  \_getOrderCost (compositeOrder: CompositeOrder): (totalCost: Float)\
    **requires** `compositeOrder` exists.\
    **effects** Returns the `totalCost` of the `compositeOrder`.

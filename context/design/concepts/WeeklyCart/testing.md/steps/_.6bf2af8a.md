---
timestamp: 'Mon Oct 27 2025 14:28:17 GMT-0400 (Eastern Daylight Time)'
parent: '[[../20251027_142817.7a879c17.md]]'
content_id: 6bf2af8a8540769dcfb1f4b08e9cc15cf2f26145d87bf90814cc951c3a89ca25
---

# Example Test Formatting and Best Practices

This document condenses key learnings from the provided test example, emphasizing best practices for writing legible, robust, and maintainable concept tests.

## 1. Overall Testing Goals

Concept tests aim to verify:

* **Action Requirements (`requires`)**: Ensure actions correctly prevent execution or return an error when preconditions are not met.
* **Action Effects (`effects`)**: Confirm that the state changes and results produced by an action align with its postconditions.
* **Principle Fulfillment**: Demonstrate that a series of actions, as described in the **principle**, leads to the expected functional outcome.

## 2. Test File Structure and Organization

Tests should be organized logically to enhance readability and maintainability.

* **Top-Level Tests (`Deno.test`)**: Each `Deno.test` block should focus on a major aspect, such as verifying the concept's operational principle or a specific functional case. Use descriptive names.
* **Steps (`t.step`)**: Break down each top-level test into sequential steps using `t.step`. These steps should correspond to logical phases or individual actions within the test scenario.
* **Logging for Clarity**: Use helper functions like `printTestHeader` and `printStepHeader` to clearly delineate the current test and step in the console output, making it easy to follow the test's flow.

```typescript
// Example of test structure and logging
Deno.test("StoreCatalog - Operating Principle Verification", async (t) => {
  printTestHeader(t.name);
  const [db, client] = await testDb();
  const storeCatalog = new StoreCatalogConcept(db);

  await t.step("1. Administrator creates a new item (ground pepper)", async () => {
    printStepHeader("1. Administrator creates a new item (ground pepper)");
    // ... test logic for createItem
  });

  await t.step("2. Adds purchase options for the item", async () => {
    printStepHeader("2. Adds purchase options for the item");
    // ... test logic for addPurchaseOption
  });

  // ... further steps for addItemName, confirmPurchaseOption, etc.

  await client.close();
});
```

## 3. Detailed Assertion and Logging

For granular verification, a custom assertion helper (`assertAndLog`) is recommended.

* **Purpose of `assertAndLog`**: This helper wraps standard assertions (e.g., `assertEquals`) to provide immediate feedback in the console, indicating whether each check passed (`✅`) or failed (`❌`), along with a descriptive message. This is crucial for debugging complex multi-step tests.
* **Arguments**: It takes the actual value, expected value, a specific message for the assertion, the current step message, and a check index for unique identification.
* **Error Handling within `assertAndLog`**: It catches and logs the assertion error locally before re-throwing it, ensuring Deno's test runner correctly marks the test as failed while providing rich debugging context.

```typescript
// Helper function for assertions with logging (as provided in the prompt)
function assertAndLog<T>(
  actual: T,
  expected: T,
  message: string,
  stepMessage: string,
  checkIndex: number,
) {
  try {
    assertEquals(actual, expected, message);
    console.log(`    ✅ Check ${checkIndex}: ${message}`);
  } catch (e) {
    console.log(`    ❌ Check ${checkIndex}: ${message}`);
    console.error(`      Error in "${stepMessage}": ${message}`);
    throw e;
  }
}

// Example of usage within a test step
await t.step("1. Administrator creates a new item (ground pepper)", async () => {
  const stepMessage = "1. Administrator creates a new item (ground pepper)";
  printStepHeader(stepMessage);
  let checkIndex = 0;

  const createResult = await storeCatalog.createItem({ primaryName: "ground pepper" });
  assertAndLog(
    "item" in createResult,
    true,
    "Item creation should succeed",
    stepMessage,
    ++checkIndex,
  );
  const groundPepperItem = (createResult as { item: ID }).item; // Type assertion to access 'item'

  const queriedItem = await storeCatalog._getItemByName({ name: "ground pepper" });
  assertAndLog(
    "error" in queriedItem, // First, check if it's an error
    false,
    "Query by name should not return an error",
    stepMessage,
    ++checkIndex,
  );
  assertAndLog(
    (queriedItem as { item: ID }[]).length, // Then, assert its length after casting
    1,
    "Query by name should find the created item",
    stepMessage,
    ++checkIndex,
  );
  assertAndLog(
    (queriedItem as { item: ID }[])[0].item, // Access the first element after casting
    groundPepperItem,
    "Queried item ID should match the created item ID",
    stepMessage,
    ++checkIndex,
  );
});
```

## 4. Accessing Action and Query Outputs During Testing

A crucial aspect of testing concepts is correctly accessing the results returned by actions and queries, which follow specific patterns:

* **Actions**: Typically return a `Result<T>` type, which is either `T` (a dictionary object with specific fields, potentially `Empty` for no explicit return) or `{ error: string }`.
* **Queries**: Always return a `Result<T[]>` type, meaning an *array* of results or an `{ error: string }` object.

Here's how to properly handle these outputs:

### A. Checking for Success vs. Error

Before accessing any data, always determine if the operation was successful or if an error occurred.

* **For successful actions returning a specific payload (e.g., `Result<{ recipe: ID }>`):**
  ```typescript
  const createResult = await cookBook.createRecipe({ name: "Spicy Pasta", user: chefAlice });
  assertAndLog("recipe" in createResult, true, "Recipe creation should succeed", stepMessage, ++checkIndex);
  // If the above passes, TypeScript now knows `createResult` is `{ recipe: ID }`
  const spicyPastaRecipeId = (createResult as { recipe: ID }).recipe;
  ```
  Here, `"recipe" in createResult` is used as a type guard to confirm the success case.

* **For successful actions returning `Empty` (e.g., `Result<Empty>`):**
  ```typescript
  const addPastaResult = await cookBook.addRecipeIngredient({ /* ... */ });
  assertAndLog("error" in addPastaResult, false, "Adding pasta should succeed (no error)", stepMessage, ++checkIndex);
  // No specific data to extract, just verify no error.
  ```

* **For successful queries returning an array (e.g., `Result<Item[]>`):**
  ```typescript
  const details = await cookBook._getRecipeDetails({ recipe: spicyPastaRecipeId });
  assertAndLog("error" in details, false, "Query recipe details should not return an error", stepMessage, ++checkIndex);
  // If the above passes, TypeScript now knows `details` is the array type.
  assertAndLog((details as { name: string }[]).length, 1, "Should find one recipe detail", stepMessage, ++checkIndex);
  assertAndLog((details as { name: string }[])[0].name, "Spicy Pasta", "Recipe name should match", stepMessage, ++checkIndex);
  ```
  Note the explicit cast `(details as { name: string }[])` after confirming `!("error" in details)`. This helps TypeScript understand the structure and allows access to array methods like `length` or indexing like `[0]`.

* **For expected errors (both actions and queries):**
  ```typescript
  const emptyNameResult = await cookBook.createRecipe({ name: "", user: testUser });
  assertAndLog("error" in emptyNameResult, true, "Should return error for empty name", stepMessage, ++checkIndex);
  assertAndLog(
    (emptyNameResult as { error: string }).error,
    "Recipe name cannot be empty.",
    "Error message for empty name mismatch",
    stepMessage,
    ++checkIndex,
  );
  ```
  Here, `"error" in emptyNameResult` acts as the type guard, allowing safe access to `emptyNameResult.error`.

### B. Type Assertions for Safe Access

TypeScript needs help to narrow down union types. Use type assertions (`as Type`) after a type guard check to tell TypeScript what type the variable is, allowing you to access its specific properties or methods.

* `const myId = (createResult as { id: ID }).id;`
* `const firstItem = (queryResult as Item[])[0];`
* `const errorMessage = (errorResult as { error: string }).error;`

### C. Handling Optional Chaining and Existence

When dealing with potentially `undefined` or `null` values (e.g., from `Array.prototype.find` or optional chaining `?.`), it's best practice to first assert their existence before accessing their properties. The `assertExistsAndLog` helper is ideal for this.

```typescript
const ingredients = await cookBook._getRecipeIngredients({ recipe: recipeId });
// ... (assert ingredients is not an error and is an array)

const flour = (ingredients as { ingredients: { name: string; quantity: number; units: string }[] }[])[0]
  .ingredients.find((i) => i.name === "Flour");

assertExistsAndLog(flour, "Flour ingredient should exist", stepMessage, ++checkIndex); // Assert existence first
assertAndLog(flour.quantity, 300, "Flour quantity should be updated", stepMessage, ++checkIndex); // Now safely access properties
```

## 5. Database Management

Ensure a clean test environment for each test run.

* **`testDb()` Utility**: Use `await testDb()` to get a fresh database instance for each test. This utility handles establishing a connection and implicitly ensures the database is clean (as per the prompt, `Deno.test.beforeAll` handles dropping the database).
* **Client Closure**: Always remember to `await client.close()` at the end of each `Deno.test` block to release database resources.

```typescript
import { testDb } from "@utils/database.ts";

Deno.test("MyConcept - Some Feature", async (t) => {
  const [db, client] = await testDb();
  const myConcept = new MyConcept(db);

  // ... test steps ...

  await client.close(); // Important: Close the client
});
```

## 6. Testing Library

Within `utils/testing.ts` are all of the necessary predefined functions necessary for testing: `assertAndLog`, `assertExistsAndLog`, `printStepHeader`, and `printTestHeader`.
